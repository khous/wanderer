#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S4,     rightBumper,    sensorEV3_Touch, modeEV3Bump)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define BUMPER_ERR_PERIOD 100
#define SPIN_DURATION 200

int rng (int range, int offset) {
	int random = randlong() % range;
	return random + offset;
}

void stopMotors () {
	motor[leftMotor] = motor[rightMotor] = 0;
}


// Tests the wandering function for challenge 1
task wander() {
	while (true) {
	//

	// Onstart Direction:
	//	forward for rand amount of time
	// On Previously left turn:
	//	next left = 10%
	//	next right = 90%
	// On Previously right turn:
	//	next left = 90%
	//  next right = 10%
		int rndLeft =  rng(10, 44);
		int rndRight = rng(5, 52);
		motor[leftMotor] = rndLeft;		// Full speed forward
		motor[rightMotor] = rndRight;
		wait1Msec(rng(2000, 1000));

		rndLeft =  rng(5, 52);
		rndRight = rng(10, 44);
		motor[leftMotor] = rndLeft;		// Full speed forward
		motor[rightMotor] = rndRight;
		wait1Msec(rng(500, 2500));

	// While (bumper not engaged)
	// move forward for random time
	// pick random direction d = (left/right)
	// stop 1 sec
	// swing turn in direction d for random time
	// stop 1 sec
	}
}

void wait (int millis) {
	delay(millis);
}

void resetBumpers () {
	resetBumpedValue(rightBumper);
	resetBumpedValue(leftBumper);
}

void backup (int direction) {
	motor[leftMotor] = motor[rightMotor] = -32;
	setSoundVolume(64);
	if (direction == -1)
		playTone(400, 25); // A for 0.05 seconds

	wait1Msec(1000);		 // A for 0.05 seconds

	switch (direction) {
		case 0://left case, so we wanna go right
			motor[leftMotor] = 32;
			motor[rightMotor] = -32;
			break;

		case 1://right case
			motor[leftMotor] = -32;
			motor[rightMotor] = 32;
			break;

		default://make sound, backup, then pause 2s, then random direction
			stopMotors();
			wait(2000);

			int rand = rng(16, 16);
			int neg = rng(2, 0) == 1 ? -1 : 1;
			rand *= neg;
			motor[leftMotor] = rand;
			motor[rightMotor] = -rand;
	}

	wait(SPIN_DURATION + rng(400, 0));
}



task bumpDetection() {
	resetBumpers();

	while (true) {
		if (getBumpedValue(rightBumper) > 0) {
			wait(BUMPER_ERR_PERIOD);
			stopMotors();
			//This indicates a head on collision
			if (getBumpedValue(leftBumper) > 0) {
				stopTask(wander);
				backup(-1);
			} else {
				stopTask(wander);
				backup(1);
			}
			resetBumpers();

			startTask(wander);
		} else if (getBumpedValue(leftBumper)	> 0) {
			wait(BUMPER_ERR_PERIOD);
			stopMotors();
			//This indicates a head on collision
			if (getBumpedValue(rightBumper) > 0) {
				stopTask(wander);
				backup(-1);
			} else {
				stopTask(wander);
				backup(0);
			}
			resetBumpers();

			startTask(wander);
		}
	}
}

task main() {
	playTone(100, 25); // A for 0.05 seconds
	startTask(wander);
	startTask(bumpDetection);

	while (true);


/*
	resetBumpedValue(rightBumper);

	while (true) {
		if (getBumpedValue(rightBumper) > 0) {
			playSound();
			resetBumpedValue(rightBumper);
		}
	}
*/
}