#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S4,     rightBumper,    sensorEV3_Touch, modeEV3Bump)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This program is solely used to test robot functionality

void playSound() {

	//setSoundVolume(127);
	playTone(400, 50); // A for 0.05 seconds
	wait1Msec(50);		 // A for 0.05 seconds

}

void stopMotors () {
	motor[leftMotor] = motor[rightMotor] = 0;
}



void moveNCoast() {

	while (true) {
		// Test run
		motor[leftMotor] = 127;		// Full speed forward
		motor[rightMotor] = 127;	// Full speed forward
		wait1Msec(1000);	// 1 seconds

		for (int i = 127; i >= 0; i--) {
			motor[leftMotor] = 	i;		// Full speed forward
			motor[rightMotor] = i;	// Full speed forward
			wait1Msec(100);	// 0.1 second
		}

		motor[leftMotor] = 0;			// Stop
		motor[rightMotor] = 0;		// Stop
		wait1Msec(3000);	// 3 seconds
	}
}



// Tests the wandering function for challenge 1
task wander() {
	while (true) {
	//

	// Onstart Direction:
	//	forward for rand amount of time
	// On Previously left turn:
	//	next left = 10%
	//	next right = 90%
	// On Previously right turn:
	//	next left = 90%
	//  next right = 10%

		motor[leftMotor] = 32;		// Full speed forward
		motor[rightMotor] = 64;
		wait1Msec(3000);


		motor[leftMotor] = 64;		// Full speed forward
		motor[rightMotor] = 32;
		wait1Msec(3000);

	// While (bumper not engaged)
	// move forward for random time
	// pick random direction d = (left/right)
	// stop 1 sec
	// swing turn in direction d for random time
	// stop 1 sec
	}
}

void wait (int millis) {
	wait1Msec(millis);
}

void resetBumpers () {
	resetBumpedValue(rightBumper);
	resetBumpedValue(leftBumper);
}

void backup (int direction) {
	motor[leftMotor] = motor[rightMotor] = -32;
	setSoundVolume(127);
	for (int i = 0; i < 20; i++) {//this accounts for two seconds of backing up
		playTone(400, 25); // A for 0.05 seconds
		wait1Msec(100);		 // A for 0.05 seconds
	}

	switch (direction) {
		case 0://left case, so we wanna go right
			motor[leftMotor] = 32;
			motor[rightMotor] = -32;
			break;

		case 1://right case
			motor[leftMotor] = -32;
			motor[rightMotor] = 32;
			break;

		default:
			motor[leftMotor] = 127;
			motor[rightMotor] = -127;
	}

	wait(666);
}



task bumpDetection() {
	resetBumpers();

	while (true) {
		if (getBumpedValue(rightBumper) > 0) {
			wait(10);
			stopMotors();
			//This indicates a head on collision
			if (getBumpedValue(leftBumper) > 0) {
				backup(-1);
			}

			resetBumpers();
			stopTask(wander);
			backup(1);

			startTask(wander);
		} else if (getBumpedValue(leftBumper)	> 0) {
			wait(10);
			stopMotors();
			//This indicates a head on collision
			if (getBumpedValue(rightBumper) > 0) {
				backup(-1);
			}

			resetBumpers();
			stopTask(wander);
			backup(0);

			startTask(wander);
		}
	}
}

task main() {
	startTask(wander);
	startTask(bumpDetection);

	while (true);


/*
	resetBumpedValue(rightBumper);

	while (true) {
		if (getBumpedValue(rightBumper) > 0) {
			playSound();
			resetBumpedValue(rightBumper);
		}
	}
*/
}
