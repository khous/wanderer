#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S4,     rightBumper,    sensorEV3_Touch, modeEV3Bump)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//This is the grace period for detecting a head on collision in milliseconds
#define BUMPER_ERR_PERIOD 100
//This is the minimum time the robot will spin after backing up
#define SPIN_DURATION 200
//This is the variation in maneuvers in the wandering behavior
#define MANEUVER_DUR_VARIANCE 500
//This is the minimum time duration of a maneuver in the wandering routine
#define MANEUVER_DUR_MIN 2500
/*
	Random Number Gen
	Produce a random number with the given range offset from 0 to the specified offset
	range: the range of the number produced
	offset: A number added to the number produced to put this number higher or lower in the range
*/
int rng (int range, int offset) {
	int random = randlong() % range;
	return random + offset;
}

/*
	Alias for the wait1MSec function because the function name is ridiculous
*/
void wait (int millis) {
	wait1Msec(millis);
}

/*
	Stop all motors
*/
void stopMotors () {
	motor[leftMotor] = motor[rightMotor] = 0;
}

/*
	Display a biased random walk in the forward direction
*/
task wander() {
	while (true) {
	
		//this is the lef turn biased block
		// The two motor speeds overlap however, so though unlikely, it is possible for a turn in any direction
		int rndLeft =  rng(10, 44);
		int rndRight = rng(5, 52);
		motor[leftMotor] = rndLeft;		
		motor[rightMotor] = rndRight;
		wait(rng(MANEUVER_DUR_VARIANCE, MANEUVER_DUR_MIN));

		//This is the right turn biased block
		rndLeft =  rng(5, 52);
		rndRight = rng(10, 44);
		motor[leftMotor] = rndLeft;		
		motor[rightMotor] = rndRight;
		wait(rng(MANEUVER_DUR_VARIANCE, MANEUVER_DUR_MIN));
	}
}

/*
	Reset the bump event count for our bumpers
*/
void resetBumpers () {
	resetBumpedValue(rightBumper);
	resetBumpedValue(leftBumper);
}

/*
	Perform a backup maneuver
	direction: 0 -> backup and turn right
			   1 -> backup and turn left
			   -1-> do the middle hit dance
*/
void backup (int direction) {
	motor[leftMotor] = motor[rightMotor] = -32;
	setSoundVolume(64);
	if (direction == -1)
		playTone(400, 25); // A for 0.05 seconds

	wait(1000);		 // A for 0.05 seconds

	switch (direction) {
		case 0://left case, so we wanna go right
			motor[leftMotor] = 32;
			motor[rightMotor] = -32;
			break;

		case 1://right case
			motor[leftMotor] = -32;
			motor[rightMotor] = 32;
			break;

		default://make sound, backup, then pause 2s, then random direction
			stopMotors();
			wait(2000);

			int rand = rng(16, 16);
			int neg = rng(2, 0) == 1 ? -1 : 1;
			rand *= neg;
			motor[leftMotor] = rand;
			motor[rightMotor] = -rand;
	}

	wait(SPIN_DURATION + rng(400, 0));
}


/*
	Listens to the bumpers for any bump events
*/
task bumpDetection() {
	resetBumpers();

	while (true) {
		if (getBumpedValue(rightBumper) > 0) {
			wait(BUMPER_ERR_PERIOD);
			stopMotors();
			//This indicates a head on collision
			if (getBumpedValue(leftBumper) > 0) {
				stopTask(wander);
				backup(-1);
			} else {
				stopTask(wander);
				backup(1);
			}
			resetBumpers();

			startTask(wander);
		} else if (getBumpedValue(leftBumper)	> 0) {
			wait(BUMPER_ERR_PERIOD);
			stopMotors();
			//This indicates a head on collision
			if (getBumpedValue(rightBumper) > 0) {
				stopTask(wander);
				backup(-1);
			} else {
				stopTask(wander);
				backup(0);
			}
			resetBumpers();

			startTask(wander);
		}
	}
}

//The main task, responsible for starting the secondary tasks of wandering and bump detection
task main() {
	playTone(100, 25); // A for 0.05 seconds
	startTask(wander);
	startTask(bumpDetection);

	//Never exit main, this causes the robot to stop
	while (true);
}