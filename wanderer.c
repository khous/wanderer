#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S4,     rightBumper,    sensorEV3_Touch, modeEV3Bump)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//This is the grace period for detecting a head on collision in milliseconds
#define BUMPER_ERR_PERIOD 100
//This is the minimum time the robot will spin after backing up
#define SPIN_DURATION 200
//This is the variation in maneuvers in the wandering behavior
#define MANEUVER_DUR_VARIANCE 500
//This is the minimum time duration of a maneuver in the wandering routine
#define MANEUVER_DUR_MIN 2500
#define RPM_GRACE 25
int average_rpm_left = 0;
int average_rpm_right = 0;
bool characterizing = false;

/*
	Random Number Gen
	Produce a random number with the given range offset from 0 to the specified offset
	range: the range of the number produced
	offset: A number added to the number produced to put this number higher or lower in the range
*/
int rng (int range, int offset) {
	int random = randlong() % range;
	return random + offset;
}

/*
	Alias for the wait1MSec function because the function name is ridiculous
*/
void wait (int millis) {
	wait1Msec(millis);
}

/*
	Stop all motors
*/
void stopMotors () {
	motor[leftMotor] = motor[rightMotor] = 0;
}

/*
	Sample the RPM for a period of time to generate an average RPM to base comparisons from
*/
void characterizeRpm () {

	characterizing = true;
	int tmp_average_left = 0,
			tmp_average_right = 0;

    for (int i = 0; i < 5; i++) {
    	tmp_average_left += getMotorRPM(leftMotor);
    	tmp_average_right += getMotorRPM(rightMotor);
    	wait(100);
  	}

  	average_rpm_left = tmp_average_left / 5;
  	average_rpm_right = tmp_average_right / 5;
  	writeDebugStreamLine("avg rt: %d\n", average_rpm_right);
  	writeDebugStreamLine("avg lt: %d\n", average_rpm_left);
  	wait(100);
  	characterizing = false;
}

/*
	Display a biased random walk in the forward direction
*/
task wander() {
	while (true) {

		//this is the left turn biased block
		// The two motor speeds overlap however, so though unlikely, it is possible for a turn in any direction
		int rndLeft =  rng(10, 44);
		int rndRight = rng(5, 52);
		motor[leftMotor] = rndLeft;
		motor[rightMotor] = rndRight;
		wait(100);
		characterizeRpm();
		wait(rng(MANEUVER_DUR_VARIANCE, MANEUVER_DUR_MIN));

		//This is the right turn biased block
		rndLeft =  rng(5, 52);
		rndRight = rng(10, 44);
		motor[leftMotor] = rndLeft;
		motor[rightMotor] = rndRight;
		wait(100);
		characterizeRpm();
		wait(rng(MANEUVER_DUR_VARIANCE, MANEUVER_DUR_MIN));
	}
}

/*
	Reset the bump event count for our bumpers
*/
void resetBumpers () {
	resetBumpedValue(rightBumper);
	resetBumpedValue(leftBumper);
}

/*
	Perform a backup maneuver
	direction: 0 -> backup and turn right
			   1 -> backup and turn left
			   -1-> do the middle hit dance
*/
void backup (int direction) {
	motor[leftMotor] = motor[rightMotor] = -32;
	setSoundVolume(64);
	//if (direction == -1)
	playTone(400, 25); // A for 0.05 seconds

	wait(1000);		 // A for 0.05 seconds

	switch (direction) {
		case 0://left case, so we wanna go right
			motor[leftMotor] = 32;
			motor[rightMotor] = -32;
			break;

		case 1://right case
			motor[leftMotor] = -32;
			motor[rightMotor] = 32;
			break;

		default://make sound, backup, then pause 2s, then random direction
			stopMotors();
			wait(2000);

			int rand = rng(16, 16);
			int neg = rng(2, 0) == 1 ? -1 : 1;
			rand *= neg;
			motor[leftMotor] = rand;
			motor[rightMotor] = -rand;
	}

	wait(SPIN_DURATION + rng(400, 0));
}

//set expected RPM on every maneuver change for each motor
//

//for convenience, 0 for left, 1 for right
bool detectMotorDrop (int motor) {
	bool drop = false;
	int diff = 0;
	if (characterizing) return false;
	switch (motor) {
		case 0:
			diff = abs(average_rpm_left - getMotorSpeed(leftMotor));
			writeDebugStreamLine("drop diff, of right motor: %d, act speed: %d", diff, getMotorSpeed(leftMotor));
			drop = diff > RPM_GRACE;
			break;
		case 1:
			diff = abs(average_rpm_right - getMotorSpeed(rightMotor));
			writeDebugStreamLine("drop diff, of right motor: %d, act speed: %d", diff, getMotorSpeed(rightMotor));
			drop = diff > RPM_GRACE;
			break;
	}

	return drop;
}

/*
	Listens to the bumpers for any bump events
*/
task bumpDetection() {
	resetBumpers();

	while (true) {
		if (characterizing) {
			wait(100);
			continue;
		}

		if (detectMotorDrop(1)) {
			wait(BUMPER_ERR_PERIOD);
			stopMotors();
			//This indicates a head on collision
			if (detectMotorDrop(0)) {
				stopTask(wander);
				backup(-1);
			} else {
				stopTask(wander);
				backup(1);
			}
			resetBumpers();

			startTask(wander);
		} else if (detectMotorDrop(0)) {
			wait(BUMPER_ERR_PERIOD);
			stopMotors();
			//This indicates a head on collision
			if (detectMotorDrop(1)) {
				stopTask(wander);
				backup(-1);
			} else {
				stopTask(wander);
				backup(0);
			}
			resetBumpers();

			startTask(wander);
		}
	}
}

//The main task, responsible for starting the secondary tasks of wandering and bump detection
task main() {
	playTone(100, 25); // A for 0.05 seconds
	startTask(wander);
	wait(100);
	startTask(bumpDetection);

	//Never exit main, this causes the robot to stop
	while (true);
}
